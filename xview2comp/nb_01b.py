
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/01b_load_data_2in1out.ipynb

from xview2comp.nb_01 import *

import matplotlib.colors as colors

class DamageCategorize():
    def __init__(self):
        self.o2i = {'un-classified':1, 'no-damage':1, 'minor-damage':2, 'major-damage':3, 'destroyed':4}
    def __call__(self, o): return self.o2i[o]

def load_features(n:Path): return json.load(open(n))['features']['xy']

def polys2mask(polys, labes=None, sz=(1024, 1024)):
    '''Write polygons to a mask using their given labels.'''
    if not labes: labes = len(polys) * [1,]
    assert len(polys) == len(labes)
    polys = [shapely.geometry.mapping(p) for p in polys]
    polys = [np.array(p['coordinates'][0], dtype=np.int32) for p in polys]
    mask = np.zeros(sz, dtype=np.uint8)
    for p, l in zip(polys, labes):
        p = np.array([p])
        cv2.fillPoly(mask, p, (l,))
    return mask

def img2damgmask(o:Path):
    ''' Transform image path to multi-label mask, where 0= no feature, 1 = , ..., etc.
    o: path to the pre-disaster image.
    '''
    nprelab = img2label_fpath(o)
    nposlab = pre2post_fpath(nprelab)
    fprelab, fposlab = load_features(nprelab), load_features(nposlab)
    fposlab = [fpos for fpre in fprelab for fpos in fposlab if fpos['properties']['uid']==fpre['properties']['uid']]
    if len(fposlab) != len(fprelab): raise Exception('Pre-disaster and post-disaster uids do not match.')

    polys = feats2polys(fprelab)
    damgs = [o['properties']['subtype'] for o in fposlab]
    labs = list(map(DamageCategorize(), damgs))

    mask0, mask = polys2mask(polys), polys2mask(polys, labs)
    mask = np.ma.masked_array(mask, mask=(mask0 > 1))
    mask = np.ma.filled(mask, fill_value=0)
    return mask

def img2damgmask_fpath(n):
    return str(n).replace('images/', 'damagemasks/').replace('_pre_', '_')

def generate_damagemasks(fnames):
    for n in fnames:
        mask = img2damgmask(n)
        fpath = img2damgmask_fpath(n)
        PIL.Image.fromarray(mask).save(fpath)

class TupleTransform():
    def __init__(self, funcs):
        if not isinstance(funcs, list): funcs = [funcs]
        self.funcs = funcs
    def __call__(self, xs):
        return tuple(compose(x, self.funcs) for x in xs)

def get_imgpaths(n): return n, pre2post_fpath(n)

def concat_channels(imgs): return torch.cat(imgs, dim=0)

CMAP = colors.ListedColormap(['None', 'b', 'c', 'orange', 'r'])

def show_sample(*imgs, mas=None, figsize=(4, 4), alpha=.4):
    _, axs = plt.subplots(nrows=1, ncols=len(imgs), figsize=figsize)
    for ax, img in zip(np.array([axs]).flatten(), imgs):
        ax.axis('off')
        ax.imshow(img.permute(1, 2, 0))
        if mas is not None:
            ax.imshow(mas[0], cmap=CMAP, alpha=alpha, vmin=0, vmax=4)